# 04-工具函数库规格

## 一、格式化工具 (format.ts)

### 1.1 JSON格式化

```typescript
// src/lib/utils/format.ts

/**
 * 格式化JSON
 */
export const formatJSON = (json: string, indent: number = 2): string => {
  try {
    const parsed = JSON.parse(json);
    return JSON.stringify(parsed, null, indent);
  } catch (error) {
    throw new Error('Invalid JSON');
  }
};

/**
 * 压缩JSON
 */
export const minifyJSON = (json: string): string => {
  try {
    const parsed = JSON.parse(json);
    return JSON.stringify(parsed);
  } catch (error) {
    throw new Error('Invalid JSON');
  }
};

/**
 * 格式化XML
 */
export const formatXML = (xml: string, indent: number = 2): string => {
  const PADDING = ' '.repeat(indent);
  let formatted = '';
  let pad = 0;

  xml = xml.trim().replace(/>\s+</g, '><');

  const nodes = xml.split(/(<[^>]+>)/g);
  for (const node of nodes) {
    if (node.match(/<\/\w/)) {
      pad -= 1;
    }
    formatted += PADDING.repeat(Math.max(0, pad)) + node + '\n';
    if (node.match(/<\w[^>]*[^\/]>.*$/)) {
      pad += 1;
    }
  }

  return formatted.trim();
};

/**
 * 格式化SQL
 */
export const formatSQL = (sql: string): string => {
  const keywords = [
    'SELECT', 'FROM', 'WHERE', 'ORDER BY', 'GROUP BY',
    'INSERT INTO', 'VALUES', 'UPDATE', 'SET', 'DELETE',
    'LEFT JOIN', 'RIGHT JOIN', 'INNER JOIN', 'OUTER JOIN',
    'AND', 'OR', 'NOT', 'IN', 'LIKE', 'BETWEEN'
  ];

  let formatted = sql.toUpperCase();
  keywords.forEach(keyword => {
    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
    formatted = formatted.replace(regex, `\n${keyword}`);
  });

  return formatted
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0)
    .join('\n');
};

/**
 * 格式化CSS
 */
export const formatCSS = (css: string): string => {
  return css
    .replace(/\s*\{\s*/g, ' {\n  ')
    .replace(/;\s*/g, ';\n  ')
    .replace(/,\s*/g, ', ')
    .replace(/\s*\}\s*/g, '\n}\n');
};
```

---

## 二、验证工具 (validate.ts)

### 2.1 通用验证

```typescript
// src/lib/utils/validate.ts

/**
 * 验证邮箱
 */
export const isEmail = (email: string): boolean => {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
};

/**
 * 验证手机号（中国大陆）
 */
export const isPhone = (phone: string): boolean => {
  const regex = /^1[3-9]\d{9}$/;
  return regex.test(phone);
};

/**
 * 验证身份证号（中国大陆）
 */
export const isIdCard = (idCard: string): boolean => {
  const regex = /^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/;
  if (!regex.test(idCard)) return false;

  // 验证校验位
  const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
  const checkCodes = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];

  let sum = 0;
  for (let i = 0; i < 17; i++) {
    sum += parseInt(idCard[i]) * weights[i];
  }

  return checkCodes[sum % 11] === idCard[17].toUpperCase();
};

/**
 * 验证IP地址
 */
export const isIP = (ip: string): boolean => {
  const ipv4Regex = /^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(::1)|::)$/;
  return ipv4Regex.test(ip) || ipv6Regex.test(ip);
};

/**
 * 验证URL
 */
export const isURL = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};

/**
 * 验证JSON
 */
export const isJSON = (str: string): boolean => {
  try {
    JSON.parse(str);
    return true;
  } catch {
    return false;
  }
};

/**
 * 验证Base64
 */
export const isBase64 = (str: string): boolean => {
  const regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  return regex.test(str) && str.length % 4 === 0;
};

/**
 * 验证十六进制颜色
 */
export const isHexColor = (color: string): boolean => {
  const regex = /^#?([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/;
  return regex.test(color);
};

/**
 * 验证UUID
 */
export const isUUID = (uuid: string): boolean => {
  const regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return regex.test(uuid);
};

/**
 * 验证MAC地址
 */
export const isMAC = (mac: string): boolean => {
  const regex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
  return regex.test(mac);
};

/**
 * 强密码验证
 * 至少8位，包含大小写字母、数字和特殊字符
 */
export const isStrongPassword = (password: string): boolean => {
  const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return regex.test(password);
};
```

---

## 三、转换工具 (convert.ts)

### 3.1 数据类型转换

```typescript
// src/lib/utils/convert.ts

/**
 * 字符串转驼峰
 * hello-world -> helloWorld
 */
export const toCamelCase = (str: string): string => {
  return str
    .replace(/[-_\s]+(.)?/g, (_, char) => char ? char.toUpperCase() : '')
    .replace(/^[A-Z]/, char => char.toLowerCase());
};

/**
 * 字符串转帕斯卡
 * hello-world -> HelloWorld
 */
export const toPascalCase = (str: string): string => {
  return str
    .replace(/[-_\s]+(.)?/g, (_, char) => char ? char.toUpperCase() : '')
    .replace(/^[a-z]/, char => char.toUpperCase());
};

/**
 * 字符串转短横线
 * helloWorld -> hello-world
 */
export const toKebabCase = (str: string): string => {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
};

/**
 * 字符串转蛇形
 * helloWorld -> hello_world
 */
export const toSnakeCase = (str: string): string => {
  return str
    .replace(/([a-z])([A-Z])/g, '$1_$2')
    .replace(/[\s-]+/g, '_')
    .toLowerCase();
};

/**
 * 首字母大写
 */
export const capitalize = (str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * 首字母小写
 */
export const uncapitalize = (str: string): string => {
  return str.charAt(0).toLowerCase() + str.slice(1);
};

/**
 * 反转字符串
 */
export const reverseString = (str: string): string => {
  return str.split('').reverse().join('');
};

/**
 * 生成随机字符串
 */
export const randomString = (length: number = 10, charset: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'): string => {
  let result = '';
  for (let i = 0; i < length; i++) {
    result += charset.charAt(Math.floor(Math.random() * charset.length));
  }
  return result;
};

/**
 * 字节转可读格式
 */
export const formatBytes = (bytes: number, decimals: number = 2): string => {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

/**
 * 数字转千分位
 */
export const formatNumber = (num: number): string => {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};

/**
 * 罗马数字转阿拉伯数字
 */
export const romanToArabic = (roman: string): number => {
  const romanNumerals: Record<string, number> = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
  };

  let result = 0;
  let prev = 0;

  for (let i = roman.length - 1; i >= 0; i--) {
    const current = romanNumerals[roman[i]];
    if (current < prev) {
      result -= current;
    } else {
      result += current;
    }
    prev = current;
  }

  return result;
};

/**
 * 阿拉伯数字转罗马数字
 */
export const arabicToRoman = (num: number): string => {
  const romanNumerals = [
    { value: 1000, symbol: 'M' },
    { value: 900, symbol: 'CM' },
    { value: 500, symbol: 'D' },
    { value: 400, symbol: 'CD' },
    { value: 100, symbol: 'C' },
    { value: 90, symbol: 'XC' },
    { value: 50, symbol: 'L' },
    { value: 40, symbol: 'XL' },
    { value: 10, symbol: 'X' },
    { value: 9, symbol: 'IX' },
    { value: 5, symbol: 'V' },
    { value: 4, symbol: 'IV' },
    { value: 1, symbol: 'I' },
  ];

  let result = '';
  for (const { value, symbol } of romanNumerals) {
    while (num >= value) {
      result += symbol;
      num -= value;
    }
  }

  return result;
};
```

---

## 四、字符串工具 (string.ts)

### 4.1 字符串操作

```typescript
// src/lib/utils/string.ts

/**
 * 截断字符串
 */
export const truncate = (str: string, length: number, suffix: string = '...'): string => {
  if (str.length <= length) return str;
  return str.substring(0, length - suffix.length) + suffix;
};

/**
 * 移除HTML标签
 */
export const stripHtml = (html: string): string => {
  return html.replace(/<[^>]*>/g, '');
};

/**
 * 转义HTML
 */
export const escapeHtml = (html: string): string => {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return html.replace(/[&<>"']/g, char => map[char]);
};

/**
 * 反转义HTML
 */
export const unescapeHtml = (html: string): string => {
  const map: Record<string, string> = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#039;': "'",
  };
  return html.replace(/&(amp|lt|gt|quot|#039);/g, char => map[char]);
};

/**
 * 高亮关键词
 */
export const highlight = (text: string, keyword: string, className: string = 'highlight'): string => {
  if (!keyword) return text;
  const regex = new RegExp(`(${keyword})`, 'gi');
  return text.replace(regex, `<span class="${className}">$1</span>`);
};

/**
 * 计算字符串相似度 (Levenshtein距离)
 */
export const similarity = (str1: string, str2: string): number => {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;

  if (longer.length === 0) return 1.0;

  const costs: number[] = [];
  for (let i = 0; i <= longer.length; i++) {
    let lastValue = i;
    for (let j = 0; j <= shorter.length; j++) {
      if (i === 0) {
        costs[j] = j;
      } else if (j > 0) {
        let newValue = costs[j - 1];
        if (longer.charAt(i - 1) !== shorter.charAt(j - 1)) {
          newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
        }
        costs[j - 1] = lastValue;
        lastValue = newValue;
      }
    }
    if (i > 0) costs[shorter.length] = lastValue;
  }

  return (longer.length - costs[shorter.length]) / longer.length;
};

/**
 * 生成slug
 */
export const slugify = (str: string): string => {
  return str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
};

/**
 * 统计字符数（区分中英文）
 */
export const countCharacters = (str: string): { chinese: number; english: number; number: number; other: number } => {
  const chinese = (str.match(/[\u4e00-\u9fa5]/g) || []).length;
  const english = (str.match(/[a-zA-Z]/g) || []).length;
  const number = (str.match(/\d/g) || []).length;
  const other = str.length - chinese - english - number;

  return { chinese, english, number, other };
};

/**
 * 生成掩码（隐藏部分信息）
 */
export const maskString = (str: string, visibleStart: number = 4, visibleEnd: number = 4, maskChar: string = '*'): string => {
  if (str.length <= visibleStart + visibleEnd) return str;
  const start = str.substring(0, visibleStart);
  const end = str.substring(str.length - visibleEnd);
  const middle = maskChar.repeat(str.length - visibleStart - visibleEnd);
  return start + middle + end;
};
```

---

## 五、数组工具 (array.ts)

### 5.1 数组操作

```typescript
// src/lib/utils/array.ts

/**
 * 数组去重
 */
export const unique = <T>(arr: T[]): T[] => {
  return Array.from(new Set(arr));
};

/**
 * 数组分组
 */
export const groupBy = <T>(arr: T[], key: keyof T): Record<string, T[]> => {
  return arr.reduce((result, item) => {
    const groupKey = String(item[key]);
    if (!result[groupKey]) result[groupKey] = [];
    result[groupKey].push(item);
    return result;
  }, {} as Record<string, T[]>);
};

/**
 * 数组分块
 */
export const chunk = <T>(arr: T[], size: number): T[][] => {
  const chunks: T[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    chunks.push(arr.slice(i, i + size));
  }
  return chunks;
};

/**
 * 数组打乱
 */
export const shuffle = <T>(arr: T[]): T[] => {
  const result = [...arr];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
};

/**
 * 数组求和
 */
export const sum = (arr: number[]): number => {
  return arr.reduce((total, num) => total + num, 0);
};

/**
 * 数组求平均值
 */
export const average = (arr: number[]): number => {
  return arr.length > 0 ? sum(arr) / arr.length : 0;
};

/**
 * 数组求最大值
 */
export const max = (arr: number[]): number => {
  return Math.max(...arr);
};

/**
 * 数组求最小值
 */
export const min = (arr: number[]): number => {
  return Math.min(...arr);
};

/**
 * 数组排序
 */
export const sortBy = <T>(arr: T[], key: keyof T, order: 'asc' | 'desc' = 'asc'): T[] => {
  return [...arr].sort((a, b) => {
    const aVal = a[key];
    const bVal = b[key];
    if (aVal < bVal) return order === 'asc' ? -1 : 1;
    if (aVal > bVal) return order === 'asc' ? 1 : -1;
    return 0;
  });
};

/**
 * 数组交集
 */
export const intersection = <T>(arr1: T[], arr2: T[]): T[] => {
  return arr1.filter(item => arr2.includes(item));
};

/**
 * 数组并集
 */
export const union = <T>(arr1: T[], arr2: T[]): T[] => {
  return unique([...arr1, ...arr2]);
};

/**
 * 数组差集
 */
export const difference = <T>(arr1: T[], arr2: T[]): T[] => {
  return arr1.filter(item => !arr2.includes(item));
};

/**
 * 数组扁平化
 */
export const flatten = <T>(arr: any[]): T[] => {
  return arr.reduce<T[]>((flat, item) => {
    return flat.concat(Array.isArray(item) ? flatten(item) : item);
  }, []);
};
```

---

## 六、日期工具 (date.ts)

### 6.1 日期操作

```typescript
// src/lib/utils/date.ts
import dayjs from 'dayjs';

/**
 * 格式化日期
 */
export const formatDate = (date: Date | string | number, format: string = 'YYYY-MM-DD HH:mm:ss'): string => {
  return dayjs(date).format(format);
};

/**
 * 相对时间
 */
export const fromNow = (date: Date | string | number): string => {
  return dayjs(date).fromNow();
};

/**
 * 日期加减
 */
export const addDate = (date: Date | string | number, amount: number, unit: dayjs.ManipulateType): Date => {
  return dayjs(date).add(amount, unit).toDate();
};

/**
 * 日期差值
 */
export const diffDate = (date1: Date | string | number, date2: Date | string | number, unit: dayjs.OpUnitType = 'day'): number => {
  return dayjs(date1).diff(dayjs(date2), unit);
};

/**
 * 判断是否为同一天
 */
export const isSameDay = (date1: Date | string | number, date2: Date | string | number): boolean => {
  return dayjs(date1).isSame(dayjs(date2), 'day');
};

/**
 * 获取星期几
 */
export const getWeekday = (date: Date | string | number): string => {
  const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
  return weekdays[dayjs(date).day()];
};

/**
 * 获取季度
 */
export const getQuarter = (date: Date | string | number): number => {
  return dayjs(date).quarter();
};

/**
 * 获取月份天数
 */
export const getDaysInMonth = (date: Date | string | number): number => {
  return dayjs(date).daysInMonth();
};

/**
 * 判断是否为闰年
 */
export const isLeapYear = (year: number): boolean => {
  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
};

/**
 * 获取年龄
 */
export const getAge = (birthday: Date | string | number): number => {
  return dayjs().diff(dayjs(birthday), 'year');
};

/**
 * 获取日期范围
 */
export const getDateRange = (start: Date | string | number, end: Date | string | number): Date[] => {
  const dates: Date[] = [];
  let current = dayjs(start);
  const last = dayjs(end);

  while (current.isBefore(last) || current.isSame(last)) {
    dates.push(current.toDate());
    current = current.add(1, 'day');
  }

  return dates;
};
```

---

## 七、颜色工具 (color.ts)

### 7.1 颜色转换

```typescript
// src/lib/utils/color.ts

/**
 * HEX转RGB
 */
export const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16),
  } : null;
};

/**
 * RGB转HEX
 */
export const rgbToHex = (r: number, g: number, b: number): string => {
  return '#' + [r, g, b].map(x => {
    const hex = x.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  }).join('');
};

/**
 * HEX转HSL
 */
export const hexToHsl = (hex: string): { h: number; s: number; l: number } | null => {
  const rgb = hexToRgb(hex);
  if (!rgb) return null;

  let { r, g, b } = rgb;
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }

  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100),
  };
};

/**
 * HSL转HEX
 */
export const hslToHex = (h: number, s: number, l: number): string => {
  s /= 100;
  l /= 100;

  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs((h / 60) % 2 - 1));
  const m = l - c / 2;
  let r = 0, g = 0, b = 0;

  if (0 <= h && h < 60) {
    r = c; g = x; b = 0;
  } else if (60 <= h && h < 120) {
    r = x; g = c; b = 0;
  } else if (120 <= h && h < 180) {
    r = 0; g = c; b = x;
  } else if (180 <= h && h < 240) {
    r = 0; g = x; b = c;
  } else if (240 <= h && h < 300) {
    r = x; g = 0; b = c;
  } else if (300 <= h && h < 360) {
    r = c; g = 0; b = x;
  }

  return rgbToHex(
    Math.round((r + m) * 255),
    Math.round((g + m) * 255),
    Math.round((b + m) * 255)
  );
};

/**
 * 调整颜色亮度
 */
export const adjustBrightness = (hex: string, percent: number): string => {
  const rgb = hexToRgb(hex);
  if (!rgb) return hex;

  const adjust = (color: number) => {
    return Math.round(Math.min(255, Math.max(0, color + (color * percent))));
  };

  return rgbToHex(adjust(rgb.r), adjust(rgb.g), adjust(rgb.b));
};

/**
 * 颜色透明度
 */
export const hexToRgba = (hex: string, alpha: number): string => {
  const rgb = hexToRgb(hex);
  if (!rgb) return hex;
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
};

/**
 * 判断颜色深浅
 */
export const isDarkColor = (hex: string): boolean => {
  const rgb = hexToRgb(hex);
  if (!rgb) return false;
  const { r, g, b } = rgb;
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness < 128;
};

/**
 * 生成互补色
 */
export const getComplementaryColor = (hex: string): string => {
  const rgb = hexToRgb(hex);
  if (!rgb) return hex;
  return rgbToHex(255 - rgb.r, 255 - rgb.g, 255 - rgb.b);
};
```

---

## 八、存储工具 (storage.ts)

### 8.1 本地存储封装

```typescript
// src/lib/utils/storage.ts

/**
 * localStorage封装
 */
export const storage = {
  /**
   * 设置值
   */
  set<T>(key: string, value: T): void {
    try {
      const serialized = JSON.stringify(value);
      localStorage.setItem(key, serialized);
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  },

  /**
   * 获取值
   */
  get<T>(key: string, defaultValue?: T): T | null {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue ?? null;
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return defaultValue ?? null;
    }
  },

  /**
   * 删除值
   */
  remove(key: string): void {
    localStorage.removeItem(key);
  },

  /**
   * 清空所有
   */
  clear(): void {
    localStorage.clear();
  },

  /**
   * 获取所有键
   */
  keys(): string[] {
    return Object.keys(localStorage);
  },

  /**
   * 获取存储大小（字节）
   */
  getSize(): number {
    let size = 0;
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        size += localStorage[key].length + key.length;
      }
    }
    return size;
  },
};

/**
 * sessionStorage封装
 */
export const sessionStorage = {
  set<T>(key: string, value: T): void {
    try {
      const serialized = JSON.stringify(value);
      window.sessionStorage.setItem(key, serialized);
    } catch (error) {
      console.error('Error saving to sessionStorage:', error);
    }
  },

  get<T>(key: string, defaultValue?: T): T | null {
    try {
      const item = window.sessionStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue ?? null;
    } catch (error) {
      console.error('Error reading from sessionStorage:', error);
      return defaultValue ?? null;
    }
  },

  remove(key: string): void {
    window.sessionStorage.removeItem(key);
  },

  clear(): void {
    window.sessionStorage.clear();
  },
};

/**
 * IndexedDB封装
 */
export class IndexedDB {
  private dbName: string;
  private version: number;
  private db: IDBDatabase | null = null;

  constructor(dbName: string, version: number = 1) {
    this.dbName = dbName;
    this.version = version;
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        // 可以在这里创建对象存储空间
      };
    });
  }

  async add(storeName: string, data: any): Promise<void> {
    if (!this.db) await this.connect();

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.add(data);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async getAll(storeName: string): Promise<any[]> {
    if (!this.db) await this.connect();

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async clear(storeName: string): Promise<void> {
    if (!this.db) await this.connect();

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.clear();

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}
```

---

## 九、加密工具 (crypto.ts)

```typescript
// src/lib/utils/crypto.ts
import CryptoJS from 'crypto-js';

/**
 * MD5哈希
 */
export const md5 = (text: string): string => {
  return CryptoJS.MD5(text).toString();
};

/**
 * SHA1哈希
 */
export const sha1 = (text: string): string => {
  return CryptoJS.SHA1(text).toString();
};

/**
 * SHA256哈希
 */
export const sha256 = (text: string): string => {
  return CryptoJS.SHA256(text).toString();
};

/**
 * SHA512哈希
 */
export const sha512 = (text: string): string => {
  return CryptoJS.SHA512(text).toString();
};

/**
 * AES加密
 */
export const aesEncrypt = (text: string, key: string, iv?: string): string => {
  const keyParsed = CryptoJS.enc.Utf8.parse(key);
  const ivParsed = iv ? CryptoJS.enc.Utf8.parse(iv) : undefined;

  const encrypted = CryptoJS.AES.encrypt(text, keyParsed, {
    iv: ivParsed,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
  });

  return encrypted.toString();
};

/**
 * AES解密
 */
export const aesDecrypt = (ciphertext: string, key: string, iv?: string): string => {
  const keyParsed = CryptoJS.enc.Utf8.parse(key);
  const ivParsed = iv ? CryptoJS.enc.Utf8.parse(iv) : undefined;

  const decrypted = CryptoJS.AES.decrypt(ciphertext, keyParsed, {
    iv: ivParsed,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
  });

  return decrypted.toString(CryptoJS.enc.Utf8);
};

/**
 * HMAC生成
 */
export const hmac = (text: string, key: string, algorithm: 'sha256' | 'sha512' = 'sha256'): string => {
  const hash = algorithm === 'sha256' ? CryptoJS.SHA256 : CryptoJS.SHA512;
  return CryptoJS.Hmac(hash, text, key).toString();
};

/**
 * 生成UUID v4
 */
export const uuid = (): string => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};
```

---

**文档版本**: v2.0
**最后更新**: 2025-01-30
