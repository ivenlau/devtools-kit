# 02-P0工具详细规格

## 一、JSON工具详细规格

### 1.1 功能需求

#### 核心功能
1. **JSON格式化**: 将压缩的JSON格式化为易读形式
2. **JSON压缩**: 移除空格和换行，减小体积
3. **JSON验证**: 检查JSON语法错误并高亮显示
4. **JSON转换**: JSON ↔ CSV、JSON ↔ XML
5. **JSON复制**: 一键复制结果
6. **文件导入**: 导入.json文件
7. **结果导出**: 下载为.json文件

### 1.2 界面设计

```
┌──────────────────────────────────────────────────────┐
│  JSON 格式化                       [格式化] [压缩]    │
├──────────────────────┬───────────────────────────────┤
│  输入 JSON           │  输出                         │
│  ┌────────────────┐  │  ┌─────────────────────────┐  │
│  │                │  │  │ {                        │  │
│  │  [粘贴JSON]    │  │  │   "name": "John",        │  │
│  │                │  │  │   "age": 30              │  │
│  │  [上传文件]    │  │  │ }                        │  │
│  │                │  │  │                         │  │
│  └────────────────┘  │  └─────────────────────────┘  │
│                      │  [复制] [清空] [下载]        │
│  ✓ 验证通过          │                               │
│  大小: 1.2 KB        │                               │
└──────────────────────┴───────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│  转换工具                                             │
│  [JSON转CSV] [JSON转XML] [JSON转YAML]                │
└──────────────────────────────────────────────────────┘
```

### 1.3 数据结构

```typescript
// src/components/tools/json/types.ts
export interface JsonToolState {
  input: string;                // 输入JSON字符串
  output: string;               // 输出JSON字符串
  isValid: boolean;             // 是否有效JSON
  error: {                      // 错误信息
    message: string;
    line?: number;
    column?: number;
  } | null;
  formatOptions: {              // 格式化选项
    indent: number;             // 缩进空格数 (2/4)
    sortKeys: boolean;          // 是否排序键
    compact: boolean;           // 是否紧凑模式
  };
  stats: {                      // 统计信息
    size: number;               // 字节数
    lineCount: number;          // 行数
    propertyCount: number;      // 属性数
  };
}

export interface JsonValidationError {
  message: string;
  line: number;
  column: number;
  position: number;
}
```

### 1.4 核心算法实现

```typescript
// src/lib/parsers/json.ts
import { JsonValidationError } from '@/components/tools/json/types';

/**
 * JSON格式化
 */
export const formatJson = (
  input: string,
  options: { indent: number; sortKeys: boolean }
): { result: string; error: JsonValidationError | null } => {
  try {
    const parsed = JSON.parse(input);

    // 递归排序键
    const sorted = options.sortKeys ? sortObjectKeys(parsed) : parsed;

    const formatted = JSON.stringify(sorted, null, options.indent);
    return { result: formatted, error: null };
  } catch (error: any) {
    return {
      result: '',
      error: parseJsonError(error, input),
    };
  }
};

/**
 * JSON压缩
 */
export const minifyJson = (input: string): { result: string; error: JsonValidationError | null } => {
  try {
    const parsed = JSON.parse(input);
    const minified = JSON.stringify(parsed);
    return { result: minified, error: null };
  } catch (error: any) {
    return {
      result: '',
      error: parseJsonError(error, input),
    };
  }
};

/**
 * JSON验证
 */
export const validateJson = (input: string): JsonValidationError | null => {
  try {
    JSON.parse(input);
    return null;
  } catch (error: any) {
    return parseJsonError(error, input);
  }
};

/**
 * JSON转CSV
 */
export const jsonToCsv = (json: string, delimiter: string = ','): string => {
  const data = JSON.parse(json);
  const array = Array.isArray(data) ? data : [data];

  if (array.length === 0) return '';

  // 提取所有可能的键
  const allKeys = Array.from(
    new Set(
      array.flatMap(obj => Object.keys(obj))
    )
  );

  // 构建CSV头部
  const headers = allKeys.join(delimiter);

  // 构建CSV数据行
  const rows = array.map(obj => {
    return allKeys.map(key => {
      const value = obj[key];
      // 处理包含分隔符的值
      if (typeof value === 'string' && (value.includes(delimiter) || value.includes('\n'))) {
        return `"${value.replace(/"/g, '""')}"`;
      }
      return value ?? '';
    }).join(delimiter);
  });

  return [headers, ...rows].join('\n');
};

/**
 * CSV转JSON
 */
export const csvToJson = (csv: string, delimiter: string = ','): string => {
  const lines = csv.trim().split('\n');
  if (lines.length < 2) return '[]';

  const headers = parseCsvLine(lines[0], delimiter);
  const data = lines.slice(1).map(line => {
    const values = parseCsvLine(line, delimiter);
    return headers.reduce((obj, header, index) => {
      obj[header] = values[index] || '';
      return obj;
    }, {} as Record<string, string>);
  });

  return JSON.stringify(data, null, 2);
};

/**
 * JSON转XML
 */
export const jsonToXml = (json: string): string => {
  const data = JSON.parse(json);
  return objectToXml(data, 'root');
};

/**
 * XML转JSON
 */
export const xmlToJson = (xml: string): string => {
  // 使用xml2js库
  const xml2js = require('xml2js');
  const parser = new xml2js.Parser();
  let result: any;

  parser.parseString(xml, (err: any, parsed: any) => {
    if (err) throw err;
    result = parsed;
  });

  return JSON.stringify(result, null, 2);
};

// 辅助函数：递归排序对象键
function sortObjectKeys(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.map(sortObjectKeys);
  }
  if (obj !== null && typeof obj === 'object') {
    return Object.keys(obj)
      .sort()
      .reduce((sorted, key) => {
        sorted[key] = sortObjectKeys(obj[key]);
        return sorted;
      }, {} as any);
  }
  return obj;
}

// 辅助函数：解析JSON错误
function parseJsonError(error: any, input: string): JsonValidationError {
  const message = error.message;
  const match = message.match(/position (\d+)/);
  const position = match ? parseInt(match[1]) : 0;

  const { line, column } = getLineAndColumn(input, position);

  return {
    message: error.message.replace(/at position \d+/, ''),
    line,
    column,
    position,
  };
}

// 辅助函数：获取错误行号和列号
function getLineAndColumn(text: string, position: number): { line: number; column: number } {
  const lines = text.substring(0, position).split('\n');
  return {
    line: lines.length,
    column: lines[lines.length - 1].length + 1,
  };
}

// 辅助函数：对象转XML
function objectToXml(obj: any, rootName: string): string {
  let xml = '';

  if (Array.isArray(obj)) {
    obj.forEach(item => {
      xml += `<item>${typeof item === 'object' ? objectToXml(item, '') : escapeXml(item)}</item>\n`;
    });
  } else if (typeof obj === 'object' && obj !== null) {
    Object.entries(obj).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        xml += `<${key}>\n${objectToXml(value, '')}</${key}>\n`;
      } else if (typeof value === 'object' && value !== null) {
        xml += `<${key}>\n${objectToXml(value, '')}</${key}>\n`;
      } else {
        xml += `<${key}>${escapeXml(value)}</${key}>\n`;
      }
    });
  } else {
    xml = String(obj);
  }

  return rootName ? `<${rootName}>\n${xml}</${rootName}>` : xml;
}

// 辅助函数：转义XML特殊字符
function escapeXml(str: any): string {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

// 辅助函数：解析CSV行
function parseCsvLine(line: string, delimiter: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === delimiter && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }

  result.push(current);
  return result;
}
```

### 1.5 组件实现

```typescript
// src/components/tools/json/JsonTool.tsx
'use client';

import React, { useState, useCallback, useEffect } from 'react';
import { JsonToolState } from './types';
import { formatJson, minifyJson, jsonToCsv, jsonToXml, validateJson } from '@/lib/parsers/json';
import { CodeEditor } from '@/components/editor/CodeEditor';
import { Button } from '@/components/ui/Button';
import { toast } from 'react-hot-toast';

export const JsonTool: React.FC = () => {
  const [state, setState] = useState<JsonToolState>({
    input: '',
    output: '',
    isValid: true,
    error: null,
    formatOptions: {
      indent: 2,
      sortKeys: false,
      compact: false,
    },
    stats: {
      size: 0,
      lineCount: 0,
      propertyCount: 0,
    },
  });

  // 自动格式化
  const autoFormat = useCallback(() => {
    if (!state.input.trim()) {
      setState(prev => ({ ...prev, output: '', isValid: true, error: null }));
      return;
    }

    const { result, error } = formatJson(state.input, state.formatOptions);

    setState(prev => ({
      ...prev,
      output: result,
      isValid: !error,
      error,
      stats: result ? calculateStats(result) : prev.stats,
    }));
  }, [state.input, state.formatOptions]);

  useEffect(() => {
    const timer = setTimeout(autoFormat, 500);
    return () => clearTimeout(timer);
  }, [autoFormat]);

  // 计算统计信息
  const calculateStats = (json: string) => ({
    size: new Blob([json]).size,
    lineCount: json.split('\n').length,
    propertyCount: (json.match(/"/g) || []).length / 2,
  });

  // 格式化按钮
  const handleFormat = () => {
    autoFormat();
    toast.success('格式化完成');
  };

  // 压缩按钮
  const handleMinify = () => {
    const { result, error } = minifyJson(state.input);
    if (error) {
      toast.error(`JSON格式错误: ${error.message}`);
    } else {
      setState(prev => ({ ...prev, output: result }));
      toast.success('压缩完成');
    }
  };

  // 复制结果
  const handleCopy = () => {
    navigator.clipboard.writeText(state.output);
    toast.success('已复制到剪贴板');
  };

  // 清空
  const handleClear = () => {
    setState(prev => ({
      ...prev,
      input: '',
      output: '',
      error: null,
      isValid: true,
    }));
  };

  // 下载文件
  const handleDownload = () => {
    const blob = new Blob([state.output], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `formatted-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    toast.success('下载成功');
  };

  // 文件导入
  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target?.result as string;
      setState(prev => ({ ...prev, input: content }));
      toast.success('文件导入成功');
    };
    reader.readAsText(file);
  };

  // 转换为CSV
  const handleConvertToCsv = () => {
    try {
      const csv = jsonToCsv(state.output);
      setState(prev => ({ ...prev, output: csv }));
      toast.success('已转换为CSV');
    } catch (error: any) {
      toast.error('转换失败: ' + error.message);
    }
  };

  // 转换为XML
  const handleConvertToXml = () => {
    try {
      const xml = jsonToXml(state.output);
      setState(prev => ({ ...prev, output: xml }));
      toast.success('已转换为XML');
    } catch (error: any) {
      toast.error('转换失败: ' + error.message);
    }
  };

  return (
    <div className="flex h-full flex-col">
      {/* 工具栏 */}
      <div className="mb-4 flex flex-wrap items-center gap-2">
        <Button onClick={handleFormat} icon={<FormatIcon />}>
          格式化
        </Button>
        <Button onClick={handleMinify} variant="secondary" icon={<CompressIcon />}>
          压缩
        </Button>
        <Button onClick={handleCopy} variant="ghost" icon={<CopyIcon />}>
          复制
        </Button>
        <Button onClick={handleDownload} variant="ghost" icon={<DownloadIcon />}>
          下载
        </Button>
        <Button onClick={handleClear} variant="ghost" icon={<TrashIcon />}>
          清空
        </Button>
        <div className="ml-auto flex items-center gap-2">
          <label className="flex cursor-pointer items-center gap-2">
            <input
              type="file"
              accept=".json"
              onChange={handleFileUpload}
              className="hidden"
            />
            <Button variant="secondary" icon={<UploadIcon />}>
              上传文件
            </Button>
          </label>
        </div>
      </div>

      {/* 选项栏 */}
      <div className="mb-4 flex items-center gap-4 rounded-md bg-gray-50 p-3 dark:bg-gray-800">
        <label className="flex items-center gap-2">
          <input
            type="number"
            min="2"
            max="8"
            value={state.formatOptions.indent}
            onChange={(e) => setState(prev => ({
              ...prev,
              formatOptions: { ...prev.formatOptions, indent: parseInt(e.target.value) }
            }))}
            className="w-16 rounded border px-2 py-1"
          />
          <span className="text-sm">空格缩进</span>
        </label>
        <label className="flex items-center gap-2">
          <input
            type="checkbox"
            checked={state.formatOptions.sortKeys}
            onChange={(e) => setState(prev => ({
              ...prev,
              formatOptions: { ...prev.formatOptions, sortKeys: e.target.checked }
            }))}
            className="rounded"
          />
          <span className="text-sm">排序键</span>
        </label>
      </div>

      {/* 编辑器区域 */}
      <div className="flex flex-1 gap-4">
        {/* 输入区 */}
        <div className="flex-1">
          <div className="mb-2 flex items-center justify-between">
            <span className="text-sm font-medium">输入 JSON</span>
            {state.error && (
              <span className="text-sm text-red-500">
                错误: 行 {state.error.line}, 列 {state.error.column}: {state.error.message}
              </span>
            )}
          </div>
          <CodeEditor
            value={state.input}
            onChange={(value) => setState(prev => ({ ...prev, input: value || '' }))}
            language="json"
            height="100%"
            className="h-full min-h-[500px]"
          />
        </div>

        {/* 输出区 */}
        <div className="flex-1">
          <div className="mb-2 flex items-center justify-between">
            <span className="text-sm font-medium">输出</span>
            {state.isValid && state.output && (
              <span className="text-sm text-green-600">
                ✓ {state.stats.lineCount} 行 · {formatBytes(state.stats.size)}
              </span>
            )}
          </div>
          <CodeEditor
            value={state.output}
            language="json"
            readOnly
            height="100%"
            className="h-full min-h-[500px]"
          />
        </div>
      </div>

      {/* 转换工具栏 */}
      <div className="mt-4 flex items-center gap-2 border-t pt-4">
        <span className="text-sm font-medium">转换为:</span>
        <Button onClick={handleConvertToCsv} variant="secondary" size="sm">
          CSV
        </Button>
        <Button onClick={handleConvertToXml} variant="secondary" size="sm">
          XML
        </Button>
      </div>
    </div>
  );
};

// 辅助函数：格式化字节
function formatBytes(bytes: number): string {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}
```

---

## 二、Base64编解码工具详细规格

### 2.1 功能需求

1. **文本编码**: 将文本编码为Base64
2. **文本解码**: 将Base64解码为文本
3. **图片转Base64**: 拖拽上传图片生成Base64
4. **Base64转图片**: 将Base64还原为图片
5. **文件转Base64**: 支持任意文件转Base64
6. **支持字符集**: UTF-8、GBK、ASCII

### 2.2 数据结构

```typescript
// src/components/tools/base64/types.ts
export interface Base64ToolState {
  mode: 'text' | 'image' | 'file';  // 模式
  input: string;                     // 输入文本/Base64
  output: string;                    // 输出Base64/文本
  encoding: 'utf-8' | 'gbk' | 'ascii'; // 字符编码
  isEncoding: boolean;               // true=编码, false=解码
  imagePreview?: string;             // 图片预览
  fileName?: string;                 // 文件名
}
```

### 2.3 核心算法

```typescript
// src/lib/encoders/base64.ts
/**
 * 文本转Base64
 */
export const base64Encode = (text: string, encoding: 'utf-8' | 'gbk' | 'ascii' = 'utf-8'): string => {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(text);
  const binary = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
  return btoa(binary);
};

/**
 * Base64转文本
 */
export const base64Decode = (base64: string, encoding: 'utf-8' | 'gbk' | 'ascii' = 'utf-8'): string => {
  try {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    const decoder = new TextDecoder(encoding);
    return decoder.decode(bytes);
  } catch (error) {
    throw new Error('无效的Base64字符串');
  }
};

/**
 * 文件转Base64
 */
export const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result as string;
      // 移除data:image/xxx;base64,前缀
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

/**
 * Base64转图片Blob
 */
export const base64ToBlob = (base64: string, mimeType: string = 'image/png'): Blob => {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return new Blob([bytes], { type: mimeType });
};

/**
 * 图片转Base64
 */
export const imageToBase64 = async (file: File): Promise<{ base64: string; dataUrl: string }> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = reader.result as string;
      const base64 = dataUrl.split(',')[1];
      resolve({ base64, dataUrl });
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

/**
 * 检测是否为Base64
 */
export const isBase64 = (str: string): boolean => {
  const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  return base64Regex.test(str) && str.length % 4 === 0;
};

/**
 * 检测MIME类型
 */
export const detectMimeType = (base64: string): string => {
  // 从文件头判断
  const header = base64.substring(0, 32);

  // PNG: 137 80 78 71 13 10 26 10
  if (header.startsWith('iVBORw0KGgo')) return 'image/png';

  // JPEG: FF D8 FF
  if (header.startsWith('/9j/')) return 'image/jpeg';

  // GIF: GIF8
  if (header.startsWith('R0lGOD')) return 'image/gif';

  // WebP: RIFF....WEBP
  if (header.startsWith('UklGR')) return 'image/webp';

  return 'image/png'; // 默认
};
```

### 2.4 组件实现

```typescript
// src/components/tools/base64/Base64Tool.tsx
'use client';

import React, { useState, useCallback } from 'react';
import { base64Encode, base64Decode, imageToBase64, base64ToBlob, detectMimeType } from '@/lib/encoders/base64';
import { Button } from '@/components/ui/Button';
import { Textarea } from '@/components/ui/Textarea';
import { Tabs, Tab } from '@/components/ui/Tabs';
import { toast } from 'react-hot-toast';
import { Upload, Download, FileImage, FileText } from 'lucide-react';

export const Base64Tool: React.FC = () => {
  const [mode, setMode] = useState<'text' | 'image'>('text');
  const [input, setInput] = useState('');
  const [output, setOutput] = useState('');
  const [encoding, setEncoding] = useState<'utf-8' | 'gbk' | 'ascii'>('utf-8');
  const [isEncoding, setIsEncoding] = useState(true);
  const [imagePreview, setImagePreview] = useState<string>('');
  const [dragActive, setDragActive] = useState(false);

  // 文本转换
  const handleConvert = useCallback(() => {
    if (!input.trim()) {
      setOutput('');
      return;
    }

    try {
      if (isEncoding) {
        // 编码模式：文本 -> Base64
        const result = base64Encode(input, encoding);
        setOutput(result);
        toast.success('编码成功');
      } else {
        // 解码模式：Base64 -> 文本
        const result = base64Decode(input, encoding);
        setOutput(result);
        toast.success('解码成功');
      }
    } catch (error: any) {
      toast.error(error.message || '转换失败');
      setOutput('');
    }
  }, [input, isEncoding, encoding]);

  // 图片转Base64
  const handleImageUpload = async (file: File) => {
    if (!file.type.startsWith('image/')) {
      toast.error('请上传图片文件');
      return;
    }

    try {
      const { base64, dataUrl } = await imageToBase64(file);
      setOutput(base64);
      setImagePreview(dataUrl);
      toast.success('图片转换成功');
    } catch (error) {
      toast.error('图片转换失败');
    }
  };

  // 拖拽处理
  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    const file = e.dataTransfer.files[0];
    if (file) {
      if (mode === 'image') {
        handleImageUpload(file);
      } else {
        // 文件转Base64
        const reader = new FileReader();
        reader.onload = (e) => {
          const result = e.target?.result as string;
          const base64 = result.split(',')[1];
          setOutput(base64);
          toast.success('文件转换成功');
        };
        reader.readAsDataURL(file);
      }
    }
  };

  // 下载图片
  const handleDownloadImage = () => {
    if (!imagePreview) return;

    const mimeType = detectMimeType(output);
    const blob = base64ToBlob(output, mimeType);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `image.${mimeType.split('/')[1]}`;
    a.click();
    URL.revokeObjectURL(url);
    toast.success('下载成功');
  };

  return (
    <div className="flex h-full flex-col">
      {/* 模式切换 */}
      <Tabs value={mode} onChange={setMode} className="mb-4">
        <Tab value="text" icon={<FileText />}>
          文本模式
        </Tab>
        <Tab value="image" icon={<FileImage />}>
          图片模式
        </Tab>
      </Tabs>

      {mode === 'text' ? (
        <>
          {/* 选项栏 */}
          <div className="mb-4 flex flex-wrap items-center gap-4">
            <Button
              variant={isEncoding ? 'primary' : 'secondary'}
              onClick={() => setIsEncoding(true)}
            >
              编码 (文本 → Base64)
            </Button>
            <Button
              variant={!isEncoding ? 'primary' : 'secondary'}
              onClick={() => setIsEncoding(false)}
            >
              解码 (Base64 → 文本)
            </Button>
            <select
              value={encoding}
              onChange={(e) => setEncoding(e.target.value as any)}
              className="rounded border px-3 py-2"
            >
              <option value="utf-8">UTF-8</option>
              <option value="gbk">GBK</option>
              <option value="ascii">ASCII</option>
            </select>
          </div>

          {/* 输入输出区 */}
          <div className="flex flex-1 gap-4">
            <div className="flex-1">
              <label className="mb-2 block text-sm font-medium">
                {isEncoding ? '输入文本' : '输入Base64'}
              </label>
              <Textarea
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder={isEncoding ? '输入要编码的文本...' : '输入要解码的Base64...'}
                className="h-full min-h-[400px] font-mono text-sm"
              />
            </div>

            <div className="flex-1">
              <label className="mb-2 block text-sm font-medium">
                {isEncoding ? 'Base64结果' : '解码结果'}
              </label>
              <Textarea
                value={output}
                readOnly
                placeholder="转换结果将显示在这里..."
                className="h-full min-h-[400px] font-mono text-sm"
              />
            </div>
          </div>

          {/* 操作按钮 */}
          <div className="mt-4 flex gap-2">
            <Button onClick={handleConvert}>转换</Button>
            <Button
              variant="secondary"
              onClick={() => {
                navigator.clipboard.writeText(output);
                toast.success('已复制');
              }}
            >
              复制结果
            </Button>
          </div>
        </>
      ) : (
        <>
          {/* 图片模式 */}
          <div className="flex flex-1 gap-4">
            {/* 拖拽上传区 */}
            <div
              onDragEnter={handleDrag}
              onDragLeave={handleDrag}
              onDragOver={handleDrag}
              onDrop={handleDrop}
              className={`
                flex-1 rounded-lg border-2 border-dashed p-8 text-center transition-colors
                ${dragActive ? 'border-primary-500 bg-primary-50' : 'border-gray-300'}
              `}
            >
              <Upload className="mx-auto h-16 w-16 text-gray-400" />
              <p className="mt-4 text-lg font-medium">拖拽图片到这里</p>
              <p className="mt-2 text-sm text-gray-500">或点击下方按钮上传</p>
              <label className="mt-4 inline-block cursor-pointer">
                <input
                  type="file"
                  accept="image/*"
                  onChange={(e) => e.target.files?.[0] && handleImageUpload(e.target.files[0])}
                  className="hidden"
                />
                <Button>选择图片</Button>
              </label>
            </div>

            {/* 结果预览区 */}
            <div className="flex-1">
              {imagePreview ? (
                <>
                  <div className="mb-2 flex items-center justify-between">
                    <span className="text-sm font-medium">预览</span>
                    <Button onClick={handleDownloadImage} variant="secondary" icon={<Download />} size="sm">
                      下载图片
                    </Button>
                  </div>
                  <img src={imagePreview} alt="Preview" className="max-h-[500px] rounded-lg border" />
                  <Textarea
                    value={output}
                    readOnly
                    placeholder="Base64字符串..."
                    className="mt-4 h-32 font-mono text-xs"
                  />
                </>
              ) : (
                <div className="flex h-full items-center justify-center text-gray-400">
                  暂无预览
                </div>
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
};
```

---

## 三、时间戳转换工具详细规格

### 3.1 功能需求

1. **时间戳转日期**: Unix时间戳 → 日期时间
2. **日期转时间戳**: 日期时间 → Unix时间戳
3. **当前时间戳**: 显示当前时间的多种格式
4. **批量转换**: 支持多个时间戳批量转换
5. **时区转换**: 不同时区时间转换

### 3.2 数据结构

```typescript
// src/components/tools/timestamp/types.ts
export interface TimestampToolState {
  currentTimestamp: number;       // 当前时间戳（秒）
  currentTimestampMs: number;     // 当前时间戳（毫秒）
  inputTimestamp: string;         // 输入时间戳
  inputDate: string;              // 输入日期
  outputDate: string;             // 输出日期
  outputTimestamp: string;        // 输出时间戳
  timezone: string;               // 时区
  format: string;                 // 日期格式
}
```

### 3.3 核心算法

```typescript
// src/lib/utils/datetime.ts
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';

dayjs.extend(utc);
dayjs.extend(timezone);

/**
 * 时间戳转日期
 */
export const timestampToDate = (
  timestamp: number,
  format: string = 'YYYY-MM-DD HH:mm:ss',
  timezone: string = 'Asia/Shanghai'
): string => {
  const ts = timestamp.toString().length === 10 ? timestamp * 1000 : timestamp;
  return dayjs(ts).tz(timezone).format(format);
};

/**
 * 日期转时间戳
 */
export const dateToTimestamp = (
  date: string,
  unit: 'seconds' | 'milliseconds' = 'seconds'
): number => {
  const ts = dayjs(date).valueOf();
  return unit === 'seconds' ? Math.floor(ts / 1000) : ts;
};

/**
 * 获取当前时间戳
 */
export const getCurrentTimestamp = (unit: 'seconds' | 'milliseconds' = 'seconds'): number => {
  return unit === 'seconds' ? Math.floor(Date.now() / 1000) : Date.now();
};

/**
 * 批量时间戳转换
 */
export const batchTimestampToDate = (
  timestamps: string[],
  format: string = 'YYYY-MM-DD HH:mm:ss'
): Array<{ original: string; converted: string; valid: boolean }> => {
  return timestamps.map(ts => {
    try {
      const timestamp = parseInt(ts);
      if (isNaN(timestamp)) {
        return { original: ts, converted: '无效时间戳', valid: false };
      }
      const converted = timestampToDate(timestamp, format);
      return { original: ts, converted, valid: true };
    } catch {
      return { original: ts, converted: '转换失败', valid: false };
    }
  });
};

/**
 * 相对时间
 */
export const getRelativeTime = (timestamp: number): string => {
  const ts = timestamp.toString().length === 10 ? timestamp * 1000 : timestamp;
  return dayjs(ts).fromNow();
};

/**
 * 日期格式列表
 */
export const DATE_FORMATS = {
  'YYYY-MM-DD HH:mm:ss': '2024-01-30 12:00:00',
  'YYYY/MM/DD HH:mm:ss': '2024/01/30 12:00:00',
  'YYYY-MM-DDTHH:mm:ssZ': '2024-01-30T12:00:00+08:00',
  'YYYY年MM月DD日 HH:mm:ss': '2024年01月30日 12:00:00',
  'MM-DD HH:mm:ss': '01-30 12:00:00',
  'HH:mm:ss': '12:00:00',
};

/**
 * 时区列表
 */
export const TIMEZONES = [
  'Asia/Shanghai',
  'Asia/Tokyo',
  'Asia/Hong_Kong',
  'Asia/Singapore',
  'America/New_York',
  'America/Los_Angeles',
  'Europe/London',
  'Europe/Paris',
  'UTC',
];
```

### 3.4 组件实现

```typescript
// src/components/tools/timestamp/TimestampTool.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { timestampToDate, dateToTimestamp, getCurrentTimestamp, DATE_FORMATS, TIMEZONES } from '@/lib/utils/datetime';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { Select } from '@/components/ui/Select';
import { toast } from 'react-hot-toast';
import { Clock, Copy } from 'lucide-react';

export const TimestampTool: React.FC = () => {
  const [currentTimestamp, setCurrentTimestamp] = useState<number>(0);
  const [currentTimestampMs, setCurrentTimestampMs] = useState<number>(0);
  const [inputTimestamp, setInputTimestamp] = useState('');
  const [outputDate, setOutputDate] = useState('');
  const [inputDate, setInputDate] = useState('');
  const [outputTimestamp, setOutputTimestamp] = useState('');
  const [timezone, setTimezone] = useState('Asia/Shanghai');
  const [format, setFormat] = useState('YYYY-MM-DD HH:mm:ss');

  // 更新当前时间
  useEffect(() => {
    const update = () => {
      setCurrentTimestamp(getCurrentTimestamp('seconds'));
      setCurrentTimestampMs(getCurrentTimestamp('milliseconds'));
    };
    update();
    const timer = setInterval(update, 1000);
    return () => clearInterval(timer);
  }, []);

  // 时间戳转日期
  const handleTimestampToDate = () => {
    if (!inputTimestamp.trim()) return;

    try {
      const timestamp = parseInt(inputTimestamp);
      if (isNaN(timestamp)) {
        toast.error('请输入有效的时间戳');
        return;
      }
      const date = timestampToDate(timestamp, format, timezone);
      setOutputDate(date);
      toast.success('转换成功');
    } catch (error) {
      toast.error('转换失败');
    }
  };

  // 日期转时间戳
  const handleDateToTimestamp = () => {
    if (!inputDate.trim()) return;

    try {
      const timestamp = dateToTimestamp(inputDate, 'seconds');
      const timestampMs = dateToTimestamp(inputDate, 'milliseconds');
      setOutputTimestamp(`${timestamp} (秒) / ${timestampMs} (毫秒)`);
      toast.success('转换成功');
    } catch (error) {
      toast.error('转换失败');
    }
  };

  // 复制当前时间戳
  const copyCurrentTimestamp = (type: 'seconds' | 'milliseconds') => {
    const ts = type === 'seconds' ? currentTimestamp : currentTimestampMs;
    navigator.clipboard.writeText(ts.toString());
    toast.success('已复制到剪贴板');
  };

  return (
    <div className="flex h-full flex-col gap-6">
      {/* 当前时间戳 */}
      <div className="rounded-lg bg-gradient-to-r from-blue-500 to-purple-500 p-6 text-white">
        <div className="flex items-center gap-3">
          <Clock className="h-8 w-8" />
          <div className="flex-1">
            <div className="text-sm opacity-90">当前时间戳</div>
            <div className="flex items-baseline gap-4">
              <div className="cursor-pointer" onClick={() => copyCurrentTimestamp('seconds')}>
                <span className="text-3xl font-bold">{currentTimestamp}</span>
                <span className="ml-2 text-sm">秒</span>
              </div>
              <div className="cursor-pointer" onClick={() => copyCurrentTimestamp('milliseconds')}>
                <span className="text-xl">{currentTimestampMs}</span>
                <span className="ml-2 text-sm">毫秒</span>
              </div>
            </div>
            <div className="mt-2 text-sm opacity-90">
              {timestampToDate(currentTimestamp, 'YYYY-MM-DD HH:mm:ss')}
            </div>
          </div>
        </div>
      </div>

      {/* 时间戳转日期 */}
      <div className="rounded-lg border bg-white p-6 dark:border-gray-700 dark:bg-gray-800">
        <h3 className="mb-4 text-lg font-semibold">时间戳 → 日期</h3>
        <div className="flex flex-col gap-4">
          <div className="flex gap-4">
            <Input
              label="输入时间戳"
              placeholder="例如: 1706610000"
              value={inputTimestamp}
              onChange={(e) => setInputTimestamp(e.target.value)}
              className="flex-1"
            />
            <Select
              label="时区"
              value={timezone}
              onChange={(e) => setTimezone(e.target.value)}
              options={TIMEZONES.map(tz => ({ value: tz, label: tz }))}
              className="w-48"
            />
            <Select
              label="格式"
              value={format}
              onChange={(e) => setFormat(e.target.value)}
              options={Object.entries(DATE_FORMATS).map(([value, label]) => ({ value, label }))}
              className="w-64"
            />
          </div>
          <Button onClick={handleTimestampToDate}>转换</Button>
          {outputDate && (
            <div className="rounded-md bg-gray-50 p-4 dark:bg-gray-900">
              <div className="flex items-center justify-between">
                <code className="text-lg">{outputDate}</code>
                <Button
                  variant="ghost"
                  icon={<Copy />}
                  onClick={() => {
                    navigator.clipboard.writeText(outputDate);
                    toast.success('已复制');
                  }}
                >
                  复制
                </Button>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* 日期转时间戳 */}
      <div className="rounded-lg border bg-white p-6 dark:border-gray-700 dark:bg-gray-800">
        <h3 className="mb-4 text-lg font-semibold">日期 → 时间戳</h3>
        <div className="flex flex-col gap-4">
          <Input
            type="datetime-local"
            label="选择日期时间"
            value={inputDate}
            onChange={(e) => setInputDate(e.target.value)}
            className="flex-1"
          />
          <Button onClick={handleDateToTimestamp}>转换</Button>
          {outputTimestamp && (
            <div className="rounded-md bg-gray-50 p-4 dark:bg-gray-900">
              <div className="flex items-center justify-between">
                <code className="text-lg">{outputTimestamp}</code>
                <Button
                  variant="ghost"
                  icon={<Copy />}
                  onClick={() => {
                    navigator.clipboard.writeText(outputTimestamp.split(' ')[0]);
                    toast.success('已复制');
                  }}
                >
                  复制
                </Button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

---

由于篇幅限制，其他P0工具（正则表达式测试器、哈希生成器、UUID生成器、Markdown编辑器、URL编解码）的详细规格将在后续文档中补充。所有工具都遵循相同的设计模式和代码规范。

---

**文档版本**: v2.0
**最后更新**: 2025-01-30
